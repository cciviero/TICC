#!/usr/bin/env python
# -*- coding: utf-8 -*-

# -------------------------------------------------------------------
#   Filename:  pyffpp_src.py
#   Purpose:   pyffpp: Python Finite Frequency Post Proc
#   Author:    Maria Tsekhmistrenko
#   Email:     mariat@earth.ox.ac.uk
#   License:   GPLv3
# -------------------------------------------------------------------

# -----------------------------------------------------------------------
# ----------------Import required Modules (Python and Obspy)-------------
# -----------------------------------------------------------------------

import ConfigParser
import glob
import copy
import sys
import os

import numpy as np
import matplotlib.pylab as plt
from matplotlib import cm
from mpl_toolkits.axes_grid1 import make_axes_locatable

from obspy.taup import TauPyModel
from obspy.geodetics import gps2dist_azimuth

import time
import pickle

# ------------------ input_reader class---------------------------


class input_reader:
    def __init__(self, inp_file):
        print '[INPUT] Reading input file %s' % inp_file
        config_ini = ConfigParser.ConfigParser()
        config_ini.read(inp_file)
        # ---------------section_phase
        self.input_path = eval(config_ini.get('section_path', 'input_path'))
        self.original_path = eval(config_ini.get('section_path', 'original_path'))

        # ---------------section_statistics
        self.cc_factor = float(config_ini.get('section_statistics', 'cc_factor'))
        self.ts_factor = float(config_ini.get('section_statistics', 'ts_factor'))
        self.clip_factor = int(config_ini.get('section_statistics', 'clip_factor'))

        self.all_statistics = eval(config_ini.get('section_statistics',
                                                  'all_statistics'))
        self.event_wise_stat = eval(config_ini.get('section_statistics',
                                                   'event_wise_stat'))
        self.selected_events = eval(config_ini.get('section_statistics',
                                                   'selected_events'))
        self.selected_events_list = eval(config_ini.get('section_statistics',
                                                        'selected_events_list'))
        # ---------------section_amplitude
        self.amplitude_plot = eval(config_ini.get('section_amplitude',
                                                  'amplitude_plot'))
        # ---------------section_vtk
        self.proc_vtk = eval(config_ini.get('section_vtk', 'proc_vtk'))
        self.ph_phase = eval(config_ini.get('section_vtk', 'ph_phase'))
        self.vtk_file_opt = eval(config_ini.get('section_vtk', 'vtk_file_opt'))
        self.vtk_existing_file = eval(config_ini.get('section_vtk', 'vtk_existing_file'))
        self.vtk_input_path = eval(config_ini.get('section_vtk', 'vtk_input_path'))
        self.vtk_input_files = eval(config_ini.get('section_vtk', 'vtk_input_files'))


# ------------------- bc --------------------


class bc:
    grey = '\033[90m'  # broing information
    yellow = '\033[93m'  # FYI
    orange = '\033[0;33m'  # Warning

    lred = '\033[1;31m'  # there is smoke
    red = '\033[91m'  # fire!
    dred = '\033[2;31m'  # Everything is on fire

    lblue = '\033[1;34m'
    blue = '\033[94m'
    dblue = '\033[2;34m'

    lgreen = '\033[1;32m'  # all is normal
    green = '\033[92m'  # something else
    dgreen = '\033[2;32m'  # even more interesting

    lmagenta = '\033[1;35m'
    magenta = '\033[95m'  # for title
    dmagenta = '\033[2;35m'

    cyan = '\033[96m'  # system time
    white = '\033[97m'  # final time

    black = '\033[0;30m'

    end = '\033[0m'
    bold = '\033[1m'
    under = '\033[4m'


# ------------------ read output files genereted from pyffproc  ------------------


def read_ampstt(path, event_name, band):
    """
    In order to extract quickly the information from ffproc.ampstt.band0?
    generated by pyffporc
    :param path: path to the folder where the events are stored going
                 to the ampstt files
    :param event_name: the name of the event, e.g. '20130924_35'
    :param band: which band should be read
    :return: the whole file as a np.array[line -> stations / column -> information]
    How to read the station list:
    0 idx
    1 grp
    2 stla
    3 stlo
    4 stazie
    5 stnam
    6 xc_coeff
    7 Tobs
    8 dT
    9 sigma_dT
    10 not_used
    11 not_used
    12 A
    13 sigma_A
    14 not_used
    15 not_used
    16 tB_smgr
    17 tB_mfi
    18 winlen
    19 clip_taumax
    not_used
    SNR
    [ts_step1    ts_step2    cc_step1    cc_step2    clip_step1    clip_step2]
    """

    dt = np.dtype([('idx', int), ('grp', int), ('stlat', float), ('stlon', float), ('epd', float),
                   ('name', 'S10'), ('cc', float), ('tobs', float), ('dt', float), ('sigma_t', float),
                   ('N/A_1', 'S10'), ('N/A_2', 'S10'), ('f_amp', float), ('sigma_a', float), ('N/A_3', 'S10'),
                   ('N/A_4', 'S10'), ('tB_smgr', float), ('tB_mfi', float),
                   ('winlen', float), ('clip', int), ('N/A_5', 'S10'), ('snr', float)])

    ampstt_dir = os.path.join(path, event_name, 'outfiles', 'ffproc.ampstt.band%02d' % band)
    try:
        station_list = np.loadtxt(ampstt_dir, dtype=dt, ndmin=1)
    except Exception, e:
        print '%s:This is not an ffproc.ampstt file' % ampstt_dir
        return None

    if np.shape(station_list) == ():
        station_list = np.array([station_list])

    return station_list


#  ------------------ read kernel_filter.txt ------------------


def read_kernel_filter(path, event_name):
    '''
    :param path:
    :param event_name:
    :return:
    '''
    dt = np.dtype([('band', 'S10'), ('type', 'S10'), ('dominant_period', float), ('sigma', float)])
    # import ipdb; ipdb.set_trace()
    kernel_filter_dir = os.path.join(path, event_name, 'outfiles', 'kernel_filter.txt')
    band_info = np.loadtxt(kernel_filter_dir, dtype=dt, skiprows=1, usecols=(0, 1, 2, 3))

    return band_info


# ------------------- read out all the station information -------------------


def measurement_info(path, all_events, bands_sec, inp_ffpp):
    '''
    :param path:
    :param all_events:
    :param bands_sec:
    :param cc_factor:
    :param ts_factor:
    :param clip_factor:
    :return:
    '''

    cc_factor = inp_ffpp.cc_factor
    ts_factor = inp_ffpp.ts_factor
    clip_factor = inp_ffpp.clip_factor

    # this list will contain the information from all bands (various lengths)
    # therefore different in length
    final_cc = []
    final_ts = []
    final_amp = []
    final_mag = []
    final_azi = []
    check_all_events = copy.copy(all_events)

    # this counter counts the overall amount for all events, bands and
    # stations that are fitting the criteria
    count_criteria_true = 0
    count_criteria_false = 0

    for i, value in enumerate(bands_sec):
        band = i + 1

        cc_array = np.array([])
        t_shift_array = np.array([])
        sta_name_array = np.array([])
        ampl_array = np.array([])
        mag_array = np.array([])
        azi_array = np.array([])

        remove_bad_events = copy.copy(all_events)

        # this counter counts only the band but all events and stations that
        # fit the criteria
        count_stations = 0

        string = 'Working on Band %s' % band
        print bc.dgreen + '%s' % (len(string) * '=') + bc.end
        print bc.bold + '%s' % string + bc.end
        print bc.dgreen + '%s' % (len(string) * '=') + bc.end

        for event in check_all_events:

            info_pkl = read_event_pkl(inp_ffpp.original_path, event)
            mag = info_pkl['magnitude']

            print bc.blue + '%s' % event + bc.end
            station_list = read_ampstt(path, event, band)
            # import ipdb; ipdb.set_trace()

            if station_list is None:
                remove_bad_events.remove(event)
                print bc.dred + '%s will be removed from list!' % event + bc.end
                continue

            original_length = len(station_list)

            filter_crit = station_list['cc'] >= cc_factor
            filter_crit *= station_list['clip'] == clip_factor
            filter_crit *= abs(station_list['dt']) <= ts_factor

            station_list = station_list[filter_crit]

            updated_length = len(station_list)
            sorted_out = original_length - updated_length

            count_criteria_true += updated_length
            count_criteria_false += sorted_out
            count_stations += original_length

            cc_array = np.append(cc_array, station_list['cc'])
            t_shift_array = np.append(t_shift_array, station_list['dt'])
            sta_name_array = np.append(sta_name_array, station_list['name'])
            ampl_array = np.append(ampl_array, station_list['f_amp'])
            azi_array = np.append(azi_array, station_list['epd'])
            mag_array = np.append(mag_array, [mag]*updated_length)


        # save for each band the seleced/passed threshold information
        # order is cc, t-shift, event name, sta name
        # save_file = np.vstack((cc_array, t_shift_array, sta_name_array))

        output_dir = os.path.join(path, 'statistics_%s_%s_%s/' % (cc_factor, ts_factor, clip_factor))
        if not os.path.isdir(output_dir):
            os.makedirs(os.path.join(output_dir))

        # np.save(os.path.join(output_dir + 'ffps_%s_%s_%s_B0%s.npy' % (cc_factor, ts_factor,
        #                                                              clip_factor, band)), save_file)
        # for plotting we are going to use the saved information from the arrays

        final_cc.append(cc_array)
        final_ts.append(t_shift_array)
        final_amp.append(ampl_array)
        final_mag.append(mag_array)
        final_azi.append(azi_array)

    # import ipdb; ipdb.set_trace()

    return final_cc, final_ts, final_amp, final_mag, final_azi, output_dir, count_stations, count_criteria_true, count_criteria_false


#  ------------------ histogram plotter ------------------


def plot_hists(array, inp_ffpp,
               bands, count_stations, count_criteria_true, count_criteria_false,
               label, save_label, output_dir):
    '''
    plots the arrays, eg. cc for all bands and events, or t_shift.
    :param array:
    :param inp_ffpp:
    :param bands:
    :param count_stations:
    :param count_criteria_true:
    :param count_criteria_false:
    :param label:
    :param save_label:
    :param output_dir:
    :return:
    '''

    cc_factor = inp_ffpp.cc_factor
    ts_factor = inp_ffpp.ts_factor
    clip_factor = inp_ffpp.clip_factor

    plt.ioff()
    fig = plt.figure(frameon=False)
    fig.set_size_inches(30, 20)

    # for the specific band different colors and linewidths
    cmap = plt.get_cmap('jet_r')
    # import ipdb; ipdb.set_trace()
    colors = cmap(np.linspace(0, 1.0, len(bands)))
    line_width = range(len(bands) + 1)[::-1][0:-1]
    band_freq = bands

    if save_label == 'cc':
        bins_bin = len(np.arange(cc_factor, 1.0, 0.03)) - 1
        bins_range = [cc_factor, 1.0]
        plt.xlim(cc_factor - 0.05, 1.0)
        plt.axvline(x=cc_factor, color='r', lw=3, linestyle='--')

    if save_label == 'time_shift':
        bins_bin = len(np.arange(-ts_factor, ts_factor, 1))
        bins_range = [-ts_factor, ts_factor]
        plt.axvline(x=0, color='r', lw=3, linestyle='--')
        plt.axvline(x=0.5, color='r', lw=2, linestyle='--')
        plt.axvline(x=-0.5, color='r', lw=2, linestyle='--')
        plt.axvline(x=1, color='r', lw=1, linestyle='--')
        plt.axvline(x=-1, color='r', lw=1, linestyle='--')
        plt.axvline(x=-2, color='orange', lw=1, linestyle='--')
        plt.axvline(x=2, color='orange', lw=1, linestyle='--')

    # import ipdb; ipdb.set_trace()
    for idx, band in enumerate(bands):
        # import ipdb; ipdb.set_trace()
        y, binEdges = np.histogram(array[idx].astype(np.float), bins=bins_bin, range=bins_range)
        bin_centers = 0.5 * (binEdges[1:] + binEdges[:-1])

        # import ipdb; ipdb.set_trace()
        plt.plot(bin_centers, y, color=colors[idx], lw=line_width[idx],
                 label='B0%s - %2.2fs: %s data points' % (band, band,
                                                          len(array[idx])))

    plt.xlabel('%s' % label, size=30, weight='bold')
    plt.ylabel('number of measurements', size=30, weight='bold')
    plt.title('Histogram of Measurements\nCriteria: cc>=%s -- ts <=%s -- clip=%s'
              % (cc_factor, ts_factor, clip_factor), size=40, weight='bold')
    plt.legend(fontsize=25, loc=3)

    plt.grid(True)

    # to put the text relative to the x/y axis
    plt.annotate('Number of all measurements pro band: %s\n'
                 'Number of good measurements fitting the criteria (all bands): %s\n'
                 'Number of rejected measurements (not fitting criteria): %s'
                 % (count_stations, count_criteria_true, count_criteria_false),
                 xy=(0.02, 0.90), size=23, xycoords='axes fraction',
                 bbox=dict(boxstyle="round", facecolor='red', alpha=0.8))

    plt.xticks(weight='bold', size=18)
    plt.yticks(weight='bold', size=18)

    plt.savefig(output_dir + '%s_%s_%s_%s.png' % (save_label, cc_factor, ts_factor, clip_factor))


# ------------------- Event wise plots -------------------


def event_wise_stat_plots(inp_ffpp, path, bands, all_events):
    tic = time.time()
    # settings for plotting depends on the amount of bands there are
    cmap = plt.get_cmap('jet_r')
    colors = cmap(np.linspace(0, 1.0, len(bands)))
    line_width = range(len(bands) + 1)[::-1][0:-1]
    circle_size = [x * 5 for x in line_width]
    line_width = [x * 0.5 for x in line_width]
    band_name = bands

    # import ipdb; ipdb.set_trace()

    # imported from
    cc_factor = inp_ffpp.cc_factor
    ts_factor = inp_ffpp.ts_factor
    clip_factor = inp_ffpp.clip_factor

    print bc.green + bc.bold + '[Event-wise statistic plots] ...are generated.' + bc.end
    # ==================== FIRST PLOT ==========================

    for ev in all_events:
        print bc.cyan + bc.bold + 'Working on %s.' % ev + bc.end
        all_cc = np.array([])

        plt.figure(figsize=(20, 10))
        plt.ioff()
        plt.suptitle('Performance of measurements', weight='bold', size=18)

        # ====================
        # first sub plot cc for all results
        plt.subplot(2, 5, 1)
        plt.axvline(x=cc_factor, color='r', lw=2, linestyle='--')
        plt.title('cc', weight='bold', size=12)
        plt.xticks(weight='bold', size=10, rotation='vertical')
        plt.yticks(weight='bold', size=10)
        plt.ylabel('# of measurements', weight='bold', size=10)

        # ====================
        # second plot is for time shift
        plt.subplot(2, 5, 2)
        plt.axvline(x=0, color='r', lw=2, linestyle='--')
        plt.axvline(x=1, color='r', lw=1, linestyle='--')
        plt.axvline(x=-1, color='r', lw=1, linestyle='--')
        plt.title('dT', weight='bold', size=12)
        plt.xticks(weight='bold', size=10, rotation='vertical')
        plt.yticks(weight='bold', size=10)

        # ====================
        # 3rd plot: travel time and epd
        ax = plt.subplot(2, 5, 3)
        ax.yaxis.tick_right()
        plt.title('EPD', weight='bold', size=12)
        plt.xticks(weight='bold', size=8, rotation='vertical')
        plt.yticks(weight='bold', size=8)
        plt.ylabel('dT[s]', weight='bold', size=10)

        # ====================
        # 4th plot is for amplitude measurements vs. epd
        ax = plt.subplot(2, 5, 4)
        ax.yaxis.tick_right()
        plt.title('dA/A0', weight='bold', size=12)
        plt.ylabel('dA', weight='bold', size=10)
        plt.xticks(weight='bold', size=8, rotation='vertical')
        plt.yticks(weight='bold', size=8)

        # ====================
        # 5th plot is for amplitude measurements
        ax = plt.subplot(2, 5, 5)
        ax.yaxis.tick_right()
        plt.title('cc vs. SNR', weight='bold', size=12)
        plt.xlim(0, 1.01)
        # plt.ylim(-1, np.max(all_sta_snr))
        plt.xticks(weight='bold', size=10, rotation='vertical')
        plt.yticks(weight='bold', size=10)
        plt.ylabel('SNR', weight='bold', size=10)
        ax.yaxis.set_label_position("right")

        for band_indx, band_sec in enumerate(bands):

            station_information = read_ampstt(path, ev, band_indx + 1)

            # import ipdb; ipdb.set_trace()
            cc_array = station_information['cc']
            all_cc = np.append(all_cc, cc_array)

            dT_array = station_information['dt']
            all_sta_dist = station_information['epd']
            all_sta_amp = station_information['f_amp']
            all_sta_snr = station_information['snr']
            clip_array = station_information['clip']
            all_sta_name = station_information['name']

            try:
                nr_of_stations = len(all_sta_name)
            except Exception:
                print bc.red + 'Only one station for %s in band %s...' % (ev, band_sec) + bc.end
                nr_of_stations = 1
                all_sta_name = all_sta_name.tolist()

            # first sub plot cc for all results
            plt.subplot(2, 5, 1)
            cc_bins_bin = 20
            cc_bins_range = [0.0, 1.0]
            y, binEdges = np.histogram(cc_array, bins=cc_bins_bin, range=cc_bins_range)
            bin_centers = 0.5 * (binEdges[1:] + binEdges[:-1])
            plt.plot(bin_centers, y, c=colors[band_indx], lw=line_width[band_indx],
                     label='%s' % band_sec)
            plt.legend(fontsize=9, loc=2)

            # second plot is for time shift
            plt.subplot(2, 5, 2)
            dT_bins_bin = 20
            dT_bins_range = [-10, 10]
            y, binEdges = np.histogram(dT_array, bins=dT_bins_bin, range=dT_bins_range)
            bin_centers = 0.5 * (binEdges[1:] + binEdges[:-1])
            plt.plot(bin_centers, y, c=colors[band_indx], lw=line_width[band_indx])

            # 3rd plot: travel time and epd
            plt.subplot(2, 5, 3)
            plt.scatter(all_sta_dist, dT_array, c=colors[band_indx],
                        s=circle_size[band_indx],
                        linewidths=0,
                        alpha=.6,
                        label='%s' % band_sec)

            # 4th plot is for amplitude measurements vs. epd
            plt.subplot(2, 5, 4)
            plt.scatter(all_sta_dist, all_sta_amp,
                        c=colors[band_indx],
                        s=circle_size[band_indx],
                        linewidths=0,
                        alpha=.6, label='%s' % band_sec)

            # 5th plot is SNR vs. cc
            ax = plt.subplot(2, 5, 5)
            plt.scatter(cc_array, all_sta_snr, c=colors[band_indx],
                        s=circle_size[band_indx],
                        linewidths=0,
                        alpha=.6, label='%s' % band_sec)
            plt.legend(fontsize=9, loc=2)

            ### These part is only for  for cc >= inp_ffproc.check_min_cc; t_shift<=mmeant_clip_time2;
            ### and clip =0

            cc_2 = np.array([])
            dT_2 = np.array([])
            dA_2 = np.array([])
            snr_2 = np.array([])
            epd_2 = np.array([])

            # go through the stations
            # import ipdb; ipdb.set_trace()
            if nr_of_stations == 1:
                if cc_array >= cc_factor and dT_array <= ts_factor and clip_array == clip_factor:
                    cc_2 = np.append(cc_2, cc_value)
                    dT_2 = np.append(dT_2, dT_value)
                    dA_2 = np.append(dA_2, all_sta_amp)
                    snr_2 = np.append(snr_2, all_sta_snr)
                    epd_2 = np.append(epd_2, round(all_sta_dist, 2))
            else:
                for i in range(len(cc_array)):
                    cc_value = cc_array[i]
                    dT_value = dT_array[i]
                    clip = clip_array[i]

                    if cc_value >= cc_factor and dT_value <= ts_factor and clip == clip_factor:
                        cc_2 = np.append(cc_2, cc_value)
                        dT_2 = np.append(dT_2, dT_value)
                        dA_2 = np.append(dA_2, all_sta_amp[i])
                        snr_2 = np.append(snr_2, all_sta_snr[i])
                        epd_2 = np.append(epd_2, round(all_sta_dist[i], 2))

            # 6th plot for only good cc/dT/clip
            plt.subplot(2, 5, 6)

            y, binEdges = np.histogram(cc_2, bins=cc_bins_bin, range=cc_bins_range)
            bin_centers = 0.5 * (binEdges[1:] + binEdges[:-1])
            plt.plot(bin_centers, y, c=colors[band_indx], lw=line_width[band_indx])
            plt.axvline(x=cc_factor, color='r', lw=3, linestyle='--')

            plt.xticks(weight='bold', size=10, rotation='vertical')
            plt.yticks(weight='bold', size=10)
            plt.xlim(cc_factor - 0.2, 1.0)
            plt.ylabel('# of measurements', weight='bold', size=10)
            plt.xlabel('cc', weight='bold', size=10)

            # 7th plot for only good ccdT/clip
            plt.subplot(2, 5, 7)
            plt.axvline(x=0, color='r', lw=3, linestyle='--')
            plt.axvline(x=1, color='r', lw=2, linestyle='--')
            plt.axvline(x=-1, color='r', lw=2, linestyle='--')

            y, binEdges = np.histogram(dT_2, bins=dT_bins_bin, range=dT_bins_range)
            bin_centers = 0.5 * (binEdges[1:] + binEdges[:-1])
            plt.plot(bin_centers, y, c=colors[band_indx], lw=line_width[band_indx])

            plt.xticks(weight='bold', size=10, rotation='vertical')
            plt.yticks(weight='bold', size=10)
            plt.xlabel('dT[s]', weight='bold', size=10)

            # 8th plot for only good cc
            ax = plt.subplot(2, 5, 8)
            ax.yaxis.tick_right()

            plt.title('For cc >= %s, dT <= %s and clip = %s'
                      % (cc_factor, ts_factor, clip_factor), weight='bold',
                      size=16, color='blue')

            plt.scatter(epd_2, dT_2, c=colors[band_indx],
                        s=circle_size[band_indx],
                        linewidths=0,
                        alpha=.6, label='%s' % band_sec)

            plt.xticks(weight='bold', size=8, rotation='vertical')
            plt.yticks(weight='bold', size=8)
            plt.ylabel('dT[s]', weight='bold', size=10)

            plt.xlabel('epd [degrees]', weight='bold', size=10)

            # 9th plot for only good cc
            ax = plt.subplot(2, 5, 9)
            ax.yaxis.tick_right()

            plt.scatter(epd_2, dA_2, c=colors[band_indx],
                        s=circle_size[band_indx],
                        linewidths=0,
                        alpha=.6, label='%s' % band_sec)

            plt.xticks(weight='bold', size=8, rotation='vertical')
            plt.yticks(weight='bold', size=8)
            # plt.ylabel('Amplification (real/syn)', weight='bold', size=10)

            plt.xlabel('epd [degrees]', weight='bold', size=10)

            # 10th plot is for amplitude measurements
            ax = plt.subplot(2, 5, 10)
            ax.yaxis.tick_right()

            plt.scatter(cc_2, snr_2, c=colors[band_indx],
                        s=circle_size[band_indx],
                        linewidths=0,
                        alpha=.6)
            plt.xlim(cc_factor, 1.01)
            plt.ylim(-0.1, np.max(all_sta_snr))
            plt.xticks(weight='bold', size=10, rotation='vertical')
            plt.yticks(weight='bold', size=10)
            plt.ylabel('SNR', weight='bold', size=10)
            ax.yaxis.set_label_position("right")
            plt.xlabel('cc', weight='bold', size=10)

        plt.tight_layout(pad=0.7)
        plt.subplots_adjust(top=0.9)

        output_dir = os.path.join(path, '%s' % ev)
        plt.savefig(os.path.join(output_dir, 'ffpp_stst_%s.png' % ev), dpi=200)

        # ==================== SECOND PLOT ==========================

        print bc.magenta + bc.bold + '[Event-wise statistic plots] ...2nd plot...' + bc.end

        plt.ioff()
        fig = plt.figure(frameon=False)

        # this here is for scaling
        if nr_of_stations == 1:
            fig.set_size_inches(8, nr_of_stations * 10)
        else:
            fig.set_size_inches(len(bands), nr_of_stations * 0.5)

        ax = plt.gca()
        if nr_of_stations == 1:
            ax.set_yticks([1])
        else:
            ax.set_yticks(range(0, nr_of_stations, 1))

        ax.set_xticks(range(0, len(bands), 1))
        #
        ax.set_yticklabels(all_sta_name, weight='bold', size=11)
        ax.set_xticklabels(band_name, weight='bold', rotation='vertical')
        ax.set_xlabel('Bands', size=15, weight='bold', labelpad=20)
        ax.set_ylabel('Station(EPD [deg])', size=15, weight='bold', labelpad=30)
        if nr_of_stations > 1:
            all_cc = np.reshape(all_cc, (len(bands), -1))
        if nr_of_stations == 1:
            im = ax.imshow(np.expand_dims(all_cc, axis=0), interpolation='nearest',
                           cmap=cm.jet, vmin=0.0, vmax=1.0)
        else:
            im = ax.imshow(np.transpose(all_cc), interpolation='nearest',
                           cmap=cm.jet, vmin=0.0, vmax=1.0)
        # plt.title('%s' % all_events.name[ev], weight='bold', size=20, x=1.1, loc='left')

        # create an axes on the right side of ax. The width of cax will be 5%
        # of ax and the padding between cax and ax will be fixed at 0.05 inch.
        divider = make_axes_locatable(ax)

        if nr_of_stations == 1:
            cax = divider.append_axes("bottom", size='20%', pad=1.5)
        elif nr_of_stations > 100:
            cax = divider.append_axes("bottom", size='0.5%', pad=1.5)
        else:
            cax = divider.append_axes("bottom", size='2%', pad=1.5)

        cbar = plt.colorbar(im, cax=cax, orientation="horizontal")
        cbar.ax.set_title('CC', size=12, weight='bold')
        cbar.ax.set_xticklabels(cbar.ax.get_xticks(), weight='bold', rotation='vertical')

        try:
            plt.savefig(os.path.join(output_dir, 'ffpp_pipl_%s.png' % ev), dpi=200)
        except Exception, e:
            print bc.orange + bc.bold + '[event_wise_stat_plots] [Exception] %s' % e + bc.end
            plt.savefig(os.path.join(output_dir, 'ffpp_pipl_%s.png' % ev))

    toc = time.time()
    print '[Finished] It took %s minutes for all...' % (round((toc - tic) / 60, 4))


# Create VTK files
# ------------------- Read source information -------------------


def read_source(path, event_name):
    '''
    function to read the ffproc.source file to extract information
    :param path:
    :param event_name:
    :return:
    '''

    source_dir = os.path.join(path, event_name, 'outfiles', 'ffproc.source')
    # print source_dir
    try:
        source_fio = open(source_dir, 'r')
    except Exception, exc:
        print bc.orange + '[WARNING] [AMPINV.SOURCE] %s cannot be read!' % source_dir + bc.end
        return None

    f_source = source_fio.readlines()
    ev_year, ev_julianday, ev_hr, ev_min, ev_sec, ev_msec = f_source[1].split()
    evlat, evlon, catalog_depth, inverted_depth = f_source[3].split()
    # import ipdb; ipdb.set_trace()

    dt = np.dtype([('year', int), ('julianday', int), ('hr', int), ('min', int), ('sec', int),
                   ('msec', float), ('evlat', float), ('evlon', float), ('catalog_depth', float),
                   ('inverted_depth', float)])

    event_info = np.array([(ev_year, ev_julianday, ev_hr, ev_min, ev_sec,
                            ev_msec, evlat, evlon, catalog_depth,
                            inverted_depth)], dtype=dt)
    return event_info


# ------------------- conversion point coords to azi, dist, etc.. -------------------


def azi_dist_r_to_xyz(azi, dist, radius):
    '''
    Convert point coordinates given in azimuth, distance and radius (with
    respect to the north pole) to cartesian coordinates
    :param azi:
    :param dist:
    :param radius:
    :return:
    '''

    lat1 = (np.pi / 2 - dist)
    lon1 = azi

    xyz = np.ndarray(3)
    xyz[0] = np.cos(lon1) * np.cos(lat1)
    xyz[1] = np.sin(lon1) * np.cos(lat1)
    xyz[2] = np.sin(lat1)
    xyz *= radius

    return xyz


# ------------------- create a rotation matrix -------------------


def create_rot_mat(srclat, srclon):
    '''
    Create a rotation matrix to rotate a source at coordinates srclat, srclon
    to the north pole.
    Uses the rotation matrix as it is defined in AxiSEM.
    :param srclat:
    :param srclon:
    :return:
    '''

    srccolat = (90.0 - srclat) * np.pi / 180.0
    srclon *= np.pi / 180.0

    rot_mat = np.ndarray((3, 3))
    rot_mat[0, 0] = np.cos(srccolat) * np.cos(srclon)
    rot_mat[1, 1] = np.cos(srclon)
    rot_mat[2, 2] = np.cos(srccolat)
    rot_mat[1, 0] = np.cos(srccolat) * np.sin(srclon)
    rot_mat[2, 0] = -np.sin(srccolat)
    rot_mat[2, 1] = 0.0
    rot_mat[0, 1] = -np.sin(srclon)
    rot_mat[0, 2] = np.sin(srccolat) * np.cos(srclon)
    rot_mat[1, 2] = np.sin(srccolat) * np.sin(srclon)

    return rot_mat


# ------------------- the path to a vtk format -------------------


def path_to_vtk(evlat, evlon, reclat, reclon, evdepth_in_km, phase):
    '''
    Create a VTK file with the path from (evlat, evlon, evdepth_in_km) to
    (reclat, reclon).
    The file is saved in 'filename'.
    :param evlat: event coords
    :param evlon:
    :param reclat: receiver coords
    :param reclon:
    :param evdepth_in_km:
    :param filename:
    :return:
    '''

    # Calculate event/station distance and azimuth
    distance, azi, bazi = gps2dist_azimuth(evlat, evlon,
                                           reclat, reclon)
    distance /= 111000.0
    # print 'Distance: ', distance, ', Azimuth:', azi, ', Backazimuth:', bazi

    # Azimuth is defined clockwise, longitude anti-clockwise (multiply by -1)
    azi *= -1 * np.pi / 180.

    # Azimuth has zero in north, colat in south
    azi += np.pi

    # Calculate path with TauPy
    tp = TauPyModel()
    # import ipdb; ipdb.set_trace()
    path = tp.get_ray_paths(source_depth_in_km=evdepth_in_km,
                            distance_in_degree=distance,
                            phase_list=[phase])

    # Select first path
    try:
        path_P = path[0]
    except Exception, e:
        print bc.orange + 'No ray path could be calculated for this phase and source-receiver setting.' + bc.end
        return False, False, False

    x = []
    y = []
    z = []

    # Create rotation matrix to rotate source from (evlat, evlon) to the
    # northpole and use the inverse. (We later want to rotate a source from the
    # north pole to (evlat, evlon).
    rot_mat = np.linalg.inv(create_rot_mat(srclat=evlat,
                                           srclon=evlon))

    # XXX see this cool feature by Kasra, now diff phases crawl along the core mantle boundary
    # instead of on direct line through the core
    if "diff" in path_P.name:
        for pi in range(len(path_P.path)):
            if abs(path_P.path[pi][3] - 2889.0) < 1.:
                d_new = np.linspace(path_P.path[pi]['dist'],
                                    path_P.path[pi + 1]['dist'], 10)
                t_new = np.linspace(path_P.path[pi]['time'],
                                    path_P.path[pi + 1]['time'], 10)
                p_inp = path_P.path[pi]['p']
                depth_inp = path_P.path[pi]['depth']
                for ni in range(len(d_new)):
                    path_P.path = np.insert(path_P.path, pi + 1 + ni,
                                            (p_inp, t_new[ni], d_new[ni],
                                             depth_inp))
                break

    # Go along the path
    for step in path_P.path:
        # Convert the values for distance and depth to Cartesian coordinates,
        # assuming a source at the north pole.
        v = azi_dist_r_to_xyz(azi=azi,
                              radius=6371.0 - step[3],
                              dist=step[2])

        # Rotate the path, such that the source is at the correct location.
        v_rot = np.dot(v, rot_mat)

        x.append(v_rot[0])
        y.append(v_rot[1])
        z.append(v_rot[2])

    return x, y, z


# ------------------- writing vtk format file -------------------


def write_vtk(X, Y, Z, B, L, sum_L, range_L, output_dir, output_name):
    '''
    :param X:
    :param Y:
    :param Z:
    :param B:
    :param L:
    :param sum_L:
    :param range_L:
    :param output_dir:
    :param output_name:
    :return:
    '''

    file_name = os.path.join(output_dir, output_name)

    with open(file_name, 'w') as f:
        f.write('# vtk DataFile Version 2.0\n')
        f.write('VTK file test\n')
        f.write('ASCII\n')
        f.write('DATASET POLYDATA\n')
        f.write('POINTS %s float\n' % int(sum_L))
    f.close()

    with open(file_name, 'a') as f:
        np.savetxt(f, np.c_[X, Y, Z], fmt='%10.3f')
    f.close()

    with open(file_name, 'a') as f:
        f.write('LINES %s %s\n' % (len(L), len(L) + sum_L))
    f.close()

    with open(file_name, 'a') as f:
        len_tmp = 0
        for i in range(len(L)):
            save_array = np.array([])
            save_array = np.append(save_array, (int(L[i])))
            save_array = np.append(save_array,
                                   range_L[len_tmp:int(L[i]) + len_tmp])
            np.savetxt(f, save_array[None], fmt='%10d')
            len_tmp += int(L[i])
    f.close()

    with open(file_name, 'a') as f:
        f.write('CELL_DATA %d\n' % len(L))
        f.write('SCALARS cell_scalars float\n')
        f.write('LOOKUP_TABLE default\n')
    f.close()

    with open(file_name, 'a') as f:
        np.savetxt(f, B, fmt='%10.5f')
    f.close()


# ------------------- creating vtk files for different options -------------------


def event2vtk(evlats, evlons, evdepths_in_km):
    """
    create a vtk file for events
    :param evlats:
    :param evlons:
    :param evdepths_in_km:
    :return:
    """
    counter = 0
    xyz = []
    for i in range(len(evlats)):
        elat = evlats[i] * np.pi / 180.
        elon = evlons[i] * np.pi / 180.
        edp = evdepths_in_km[i]
        x = (6371 - edp) * np.cos(elat) * np.cos(elon)
        y = (6371 - edp) * np.cos(elat) * np.sin(elon)
        z = (6371 - edp) * np.sin(elat)
        xyz.append("%s %s %s" % (x, y, z))
        counter += 1
    fio = open('events.vtk', 'w')
    fio.writelines('# vtk DataFile Version 3.0\n')
    fio.writelines('vtk output\n')
    fio.writelines('ASCII\n')
    fio.writelines('DATASET UNSTRUCTURED_GRID\n')
    fio.writelines('POINTS %i float\n' % counter)
    for i in range(len(xyz)):
        fio.writelines('%s\n' % xyz[i])

    fio.writelines('\n')
    fio.writelines('CELLS %i %i\n' % (counter, counter * 2))
    for i in range(len(xyz)):
        fio.writelines('1 %s\n' % i)

    fio.writelines('\n')
    fio.writelines('CELL_TYPES %i\n' % counter)
    for i in range(len(xyz)):
        fio.writelines('1\n')
    fio.close()


def make_vtk(ls_input_file, vtk_path):
    for inp_file in ls_input_file:
        if not os.path.exists(inp_file):
            print("file: %s does not exist! -- continue with the next event"
                  % inp_file)
        print ("file: %s" % inp_file)

        L = np.array([])  # len of the ray calculated
        B = np.array([])
        X = np.array([])
        Y = np.array([])
        Z = np.array([])
        all_rays = np.loadtxt(inp_file, dtype="object",
                              comments="#", delimiter=",")
        #
        # import ipdb;
        # ipdb.set_trace()
        if np.shape(all_rays) == (7,):
            all_rays = [all_rays]
        elif len(all_rays) == 0:
            continue

        for one_ray in all_rays:
            evla = float(one_ray[0])
            evlo = float(one_ray[1])
            evdp = float(one_ray[2])
            stla = float(one_ray[3])
            stlo = float(one_ray[4])
            phase = one_ray[5].strip()
            val = float(one_ray[6])

            x, y, z = path_to_vtk(evla, evlo, stla, stlo, evdp, phase)
            if not x: continue

            L = np.append(L, len(x))
            X = np.append(X, x)
            Y = np.append(Y, y)
            Z = np.append(Z, z)
            B = np.append(B, val)

        sum_L = int(np.sum(L))
        range_L = range(sum_L)

        # import ipdb; ipdb.set_trace()
        file_base_name = os.path.basename(os.path.abspath(inp_file))
        vtk_file_name = "rays_%s.vtk" % os.path.splitext(file_base_name)[0]
        write_vtk(X, Y, Z, B, L, sum_L, range_L, vtk_path, vtk_file_name)


def create_vtk_input(all_events, bands, inp_ffpp):
    if inp_ffpp.vtk_file_opt == 4:
        '''ALL IN ONE OPTION'''
        print bc.cyan + 'You choose option 4! All in!' + bc.end

        output_dir = os.path.join(inp_ffpp.input_path, 'vtk')
        if not os.path.isdir(output_dir):
            os.makedirs(os.path.join(output_dir))

        file_path = os.path.join(output_dir, 'vtk-input_4.txt')
        with open(file_path, 'w') as f:
            f.write('#\tevent_lat\tevent_lon\tevent_depth(km)\tstation_lat\tstation_lon\tphase\tts_value\n')
        f.close()

        for ev in all_events:
            source_info = read_source(inp_ffpp.input_path, ev)

            for i, band in enumerate(bands):
                station_list = read_ampstt(inp_ffpp.input_path, ev, i + 1)

                for j, sta in enumerate(station_list):
                    if station_list['cc'][j] >= inp_ffpp.cc_factor and \
                                    abs(station_list['dt'][j]) <= inp_ffpp.ts_factor and \
                                    station_list['clip'][j] == inp_ffpp.clip_factor:
                        with open(file_path, 'a') as f:
                            line = '%10.3f, %10.3f, %10.3f, %10.3f, %10.3f, %10s, %10.3f\n' \
                                   % (source_info['evlat'], source_info['evlon'], source_info['catalog_depth'],
                                      station_list['stlat'][j], station_list['stlon'][j], inp_ffpp.ph_phase,
                                      station_list['dt'][j])
                            f.write(line)
                    f.close()
        return [file_path], output_dir

    if inp_ffpp.vtk_file_opt == 3:
        '''EVENT WISE OPTION'''
        print bc.cyan + 'You choose option 3! Event wise vtk files will be generated!' + bc.end
        output_dir = os.path.join(inp_ffpp.input_path, 'vtk', 'event_wise')
        if not os.path.isdir(output_dir):
            os.makedirs(os.path.join(output_dir))

        list_file_names = []
        for ev in all_events:
            file_name = 'vtk-input_3_ev-%s.txt' % ev
            file_path = os.path.join(output_dir, file_name)

            list_file_names.append(file_path)
            with open(file_path, 'w') as f:
                f.write('#\tevent_lat\tevent_lon\tevent_depth(km)\tstation_lat\tstation_lon\tphase\tts_value\n')
            f.close()

            source_info = read_source(inp_ffpp.input_path, ev)

            for i, band in enumerate(bands):
                station_list = read_ampstt(inp_ffpp.input_path, ev, i + 1)

                for j, sta in enumerate(station_list):
                    if station_list['cc'][j] >= inp_ffpp.cc_factor and \
                                    abs(station_list['dt'][j]) <= inp_ffpp.ts_factor and \
                                    station_list['clip'][j] == inp_ffpp.clip_factor:
                        with open(file_path, 'a') as f:
                            line = '%10.3f, %10.3f, %10.3f, %10.3f, %10.3f, %10s, %10.3f\n' \
                                   % (source_info['evlat'], source_info['evlon'], source_info['catalog_depth'],
                                      station_list['stlat'][j], station_list['stlon'][j], inp_ffpp.ph_phase,
                                      station_list['dt'][j])
                            f.write(line)
            f.close()
        return list_file_names, output_dir

    if inp_ffpp.vtk_file_opt == 2:
        '''BAND WISE OPTION'''
        print bc.cyan + 'You choose option 2! Band wise vtk files will be generated!' + bc.end
        output_dir = os.path.join(inp_ffpp.input_path, 'vtk', 'band_wise')
        if not os.path.isdir(output_dir):
            os.makedirs(os.path.join(output_dir))

        list_file_names = []
        for i, band in enumerate(bands):
            file_name = 'vtk-input_2_B-%s.txt' % band
            file_path = os.path.join(output_dir, file_name)
            list_file_names.append(file_path)

            with open(file_path, 'w') as f:
                f.write('#\tevent_lat\tevent_lon\tevent_depth(km)\tstation_lat\tstation_lon\tphase\tts_value\n')
            f.close()

            for ev in all_events:
                source_info = read_source(inp_ffpp.input_path, ev)
                station_list = read_ampstt(inp_ffpp.input_path, ev, i + 1)
                for j, sta in enumerate(station_list):
                    if station_list['cc'][j] >= inp_ffpp.cc_factor and \
                                    abs(station_list['dt'][j]) <= inp_ffpp.ts_factor and \
                                    station_list['clip'][j] == inp_ffpp.clip_factor:
                        with open(file_path, 'a') as f:
                            line = '%10.3f, %10.3f, %10.3f, %10.3f, %10.3f, %10s, %10.3f\n' \
                                   % (source_info['evlat'], source_info['evlon'], source_info['catalog_depth'],
                                      station_list['stlat'][j], station_list['stlon'][j], inp_ffpp.ph_phase,
                                      station_list['dt'][j])
                            f.write(line)
            f.close()
        return list_file_names, output_dir

    if inp_ffpp.vtk_file_opt == 1:
        '''BAND WISE AND EVENT WISE OPTION'''
        print bc.cyan + 'You choose option 1! You want it to be detailed, huh? Here you are...' + bc.end
        output_dir = os.path.join(inp_ffpp.input_path, 'vtk', 'band_event_wise')
        if not os.path.isdir(output_dir):
            os.makedirs(os.path.join(output_dir))

        list_file_names = []

        for ev in all_events:
            for i, band in enumerate(bands):
                file_name = 'vtk-input_1_ev-%s_B-%s.txt' % (ev, band)
                file_path = os.path.join(output_dir, file_name)
                list_file_names.append(file_path)

                with open(file_path, 'w') as f:
                    f.write('#\tevent_lat\tevent_lon\tevent_depth(km)\tstation_lat\tstation_lon\tphase\tts_value\n')
                f.close()

                source_info = read_source(inp_ffpp.input_path, ev)

                station_list = read_ampstt(inp_ffpp.input_path, ev, i + 1)

                for j, sta in enumerate(station_list):
                    if station_list['cc'][j] >= inp_ffpp.cc_factor and \
                                    abs(station_list['dt'][j]) <= inp_ffpp.ts_factor and \
                                    station_list['clip'][j] == inp_ffpp.clip_factor:
                        with open(file_path, 'a') as f:
                            line = '%10.3f, %10.3f, %10.3f, %10.3f, %10.3f, %10s, %10.3f\n' \
                                   % (source_info['evlat'], source_info['evlon'], source_info['catalog_depth'],
                                      station_list['stlat'][j], station_list['stlon'][j], inp_ffpp.ph_phase,
                                      station_list['dt'][j])
                            f.write(line)
                f.close()
        return list_file_names, output_dir

    else:
        print bc.red + bc.bold + '[ERROR] What? you cannot even count until four properly?! ' \
                                 'Go home and think about your life! [EXIT]' + bc.end


def read_event_pkl(path, event_name):
    # import ipdb; ipdb.set_trace()

    ev_load = open(os.path.join(path, event_name, 'info', 'event.pkl'), 'r')
    ev_pkl = pickle.load(ev_load)
    ev_load.close()

    return ev_pkl


def plot_amplitude(final_cc, final_ts, final_amp, final_mag, final_azi, outputdir):
    # dt-A cc-A azi-A mag-A


    plt.figure(figsize=(20, 10))
    plt.ioff()
    plt.suptitle('$Amaplitude Analytics^4$', weight='bold', size=18)
    cmap = plt.get_cmap('jet_r')
    colors = cmap(np.linspace(0, 1.0, 8))

    plt.subplot(2, 2, 1)
    plt.xlabel(r'$\frac{dA}{A_0}$')
    plt.ylabel('$dT$')

    plt.subplot(2, 2, 2)
    plt.xlabel(r'$\frac{dA}{A_0}$')
    plt.ylabel('$cc$')

    plt.subplot(2, 2, 3)
    plt.xlabel(r'$\frac{dA}{A_0}$')
    plt.ylabel('$magnitude$')

    plt.subplot(2, 2, 4)
    plt.xlabel(r'$\frac{dA}{A_0}$')
    plt.ylabel('$azimuth$')

    # --------------
    for band_nr in range(len(final_cc)):
        plt.subplot(2, 2, 1)
        plt.scatter(final_amp[band_nr], final_ts[band_nr], c=colors[band_nr], alpha=0.6, s=40)
        plt.xlim(-1, 1)

        plt.subplot(2, 2, 2)
        plt.scatter(final_amp[band_nr], final_cc[band_nr], c=colors[band_nr], alpha=0.6, s=40)
        plt.xlim(-1, 1)

        plt.subplot(2, 2, 3)
        plt.scatter(final_amp[band_nr], final_mag[band_nr], c=colors[band_nr], alpha=0.6, s=40)
        plt.xlim(-1, 1)

        plt.subplot(2, 2, 4)
        plt.scatter(final_amp[band_nr], final_azi[band_nr], c=colors[band_nr], alpha=0.6, s=40)
        plt.xlim(-1, 1)

        plt.savefig(os.path.join(outputdir, 'amplitude_analytics_band0%s.png' % (band_nr + 1)), dpi=200)
        plt.clf()