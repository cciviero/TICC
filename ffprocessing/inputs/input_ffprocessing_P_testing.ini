[section_phase]
ph_phase = 'P'
# If you want to give horizontal components for S wave measruemtns,
# first component N the second E! e.g.: ['?HN', '?HE']
ph_channel = ['?HZ']
# tag ph_horizontal only needed when ph_phase='S' otherwise not read;
# decide on whether measure T(ransversal) or R(adial) component
ph_horizontal = 'R'
# process hydrophone data? pyffproc will stop working if not clearly stated!
# ph_channel = ['BDH'] and proc_hydrophone = True
proc_hydrophone = False
ph_min_epi = 32.
ph_max_epi = 85.
; ph_min_epi = 32.
; ph_max_epi = 180.
# Background model
ph_bg = 'iasp91'
# sampling rate, lanczos method will be used for this reason
ph_sampling_rate = 10.
# preset and offset for reading the data,
# later (depends on the method), this can be changed
ph_preset = 150
ph_offset = 150
# Static preset and offset
# ph_static_preset/offset will be considered for the final length of CC or
# any other measurements
# In other words:
# ph_preset/offset (above): are used for ONLY cutting the waveforms. Take
#                           generous values as we do tapering.
# ph_static_preset/offset: are used for actual measurement (after filtering).
ph_static_preset = 0
ph_static_offset = 0

########## Examples
#ph_phase = 'P,Pdiff'
#ph_channel = ['BDH']
###################

[section_check]
# Force to process all events (even if they already exist)
force_process = False
# check all the selected events (plotting)
check_evs = True
# check the theoretical arrival times
check_ttime = True
# check both the event and stations,
# only plots for one event
check_ev_stas = True
# check the cut syntehtic waveforms
check_cut_syn = True
# check the cut real waveforms
check_cut_real = True
# plot real and synthetic waveforms top of each other
# this will be run for different bands (set the following three flags)
check_cut_real_syn = True
# plot real and synthetic waveforms top of each other and the spectra of
# real data and gabor filter
check_cut_real_syn_gabor = False
check_bands = 1-8
# minimum cross-correlation factor to be used for plotting
check_min_cc = 0.8
# plotting the projection of the measrurements on the glob
check_measured_glob = False

[section_real]
real_mode = 'read'
real_path = '/Users/cciviero/Documents/SO_PROJECT/Global_tomography/TICC/TICC-light_chiara/EVENTS'
real_name_format = 'processed'
real_id = '*.*.*.*'
real_id_state = 0
real_id_list = ['GB.*.*.*']
real_rect = -180./180./-90./90.
real_min_azi = 0
real_max_azi = 360
# DANGER: integrate real data 
int_real = False

[section_syn]
# read: in case of YSPEC synthetics
# instaseis: to work with the database mode
# WARNING: In case that you want to work with instaseis over ssh:
# python -m instaseis.server --port 8765 --buffer_size_in_mb 1024 IRIS_AK135f
# and then give the address in syn_path
# specfem: for testing purposes
syn_mode = 'instaseis'
; syn_path = 'syngine://iasp91_2s'
syn_path = '/Volumes/SEISMIC_DATA/IASP91_20s'
# The directory name in each event folder in which the synthetics are stored
syn_name_format = 'BH'
# integrate synthetic data
int_syn = False

[section_event]
# reading the event information mode
# read: read from the archive (similar to our original method)
# read_dmt: read archive retrieved with obspyDMT
#evproc_mode = 'read_dmt'
evproc_mode = 'read_dmt'
evproc_path = '/Users/cciviero/Documents/SO_PROJECT/Global_tomography/TICC/TICC-light_chiara/EVENTS/EVENTS-INFO/event_list_pickle'
evproc_name_format = '*_*.*'
evproc_min_mag = -10.
evproc_max_mag = 10.
evproc_min_depth = -10.
evproc_max_depth = 2000.
evproc_min_year = 1900
evproc_max_year = 2030
evproc_year_list = ['2017', '2018']
evproc_rect = -180./180./-90./90.
; evproc_rect = -180./10./-90./90.
selected_events = True

[section_stf]
# reading the event information mode
# read: read from the archive (similar to our original method)
# read_dmt: read archive retrieved with obspyDMT
# none: do nothing, simply
; stf_mode = 'read_dmt'
stf_mode = 'read_scardec'
# in case you are using a scardec database give path
stf_scardec_db = '/Users/cciviero/Documents/SO_PROJECT/Global_tomography/TICC/SCARDEC_STF'
# if event quality >= stf_min_qual: use the inverted STF
# else: it uses halfduration to create a STF
# 5: very good | 1: very bad
stf_min_qual = 0.0

[section_moment_tensors]
# NEW: if for some reasons there is not moment tensor information in the data 
# and no equivalent SCARDEC moment tensor information is found then a locally saved 
#Â GCMT catalouge is checked we assume for now a /year/monYY folder/file structure
gcmt_cat_path = '/Users/cciviero/Documents/SO_PROJECT/Global_tomography/TICC/GCMT/NEW_MONTHLY'

[section_measurement]
# CC-2step: original matlab code in which first the waveforms are aligned in
# the lowest frequency band and then CC is applied for all others
# CC-2step-env: similar to CC-2step but in the second step finds the
# time-window from the envelope
mmeant_mode = 'CC-2step'
# maximum time in the first and second CC steps
mmeant_clip_time1 = 7.
mmeant_clip_time2 = 3.
# calculate SNR?
mmeant_calc_snr = True

[section_output]
# original_ffprocessing: similar to the original MATLAB code (RunFFprocessing)
output_format = 'original_ffprocessing'
; output_dir = '/data/maria/global_tomography/measurements/NorthAtlantic_UCL_UPFLOW_2016-2022'
output_dir = '/Users/cciviero/Documents/SO_PROJECT/Global_tomography/TICC/OUTPUT'

# If you want to save the cut and filtered arrays as traces
save_smgr = False
only_pre_process = False

[section_kernel]
kernel_output = True
# P/S wave
kernel_ps = 'P'
kernel_comp = 'Z'
kernel_misfit = 'CC'
kernel_min_cc = 0.8

# Inverted STFs do not look like normal STFs (start from zero and end at zero) 
# as they are the results of the inversion (they can be arbitrarily complex).
# To avoid artifacts in the kernel code, STFs can be created as follow:
# 1. integral (cumulative sum) over the first STF
# 2. define the half duration as
#               (Time for 90% of the energy in the first STF)/2.
# 3. creating a Gaussian shape STF out of the half duration.
# 4. save at stf.dat
# WARNING: STF with the above method does not incorporate all 
# the high-frequency contents in our STFs.
kernel_stf_gauss = False

[section_filter]
filt_mode = 'log-gabor'

[section_log_gabor]
# Only if filt_mode in section_filter is selected as log-gabor
# center period in sec of lowest passband filter
lgb_filt_pmax = 30
# number of bandpass filters (scales)
lgb_filt_nscale = 8
# multiplicative scale factor of filter center freqs
lgb_filt_fmult = 1.4142
# is the (fixed) ratio of sigma divided by fc, where sigma is the standard
# deviation of the Gaussian that describes the log-Gabor filter in the *time*
# domain, and fc is the filter's center frequency.Hence larger sigmaIfc means
# narrower bandwidth
lgb_filt_sigmaIfc = 0.75
# desired length of zero-padded time series Choose npad>=size(tsin,1)
lgb_filt_npad = 1024
lgb_filt_energy_frac = 0.95
# lgb_filt_nlambda = 2.0 # time window changes gets bigger here
lgb_filt_nlambda = 1.0


[section_obs]
# station info contains coordinates and depth information
sta_info = '/home/maria/Codes/TICC/ffprocessing/inputs/UPFLOW_station-info.txt'
# station keys contains paths to the mseed and resp files, etc.
station_keys = '/home/maria/Codes/TICC/ffprocessing/inputs/UPFLOW_station-key.yaml'

; trace_pre_filt = [1./200, 1./150, 10, 20]
; trace_pre_filt = [0.008, 0.012, 3.0, 4.0]
trace_pre_filt = [1./200, 1./150, 40, 50]
trace_unit = 'DISP'
trace_waterlevel = 300.
trace_taper = 0.05

# apply skew correction 
skew_correction = False

# since OBS are not oriented we are measuring in this step the particle motion and write it out
particle_motion = False