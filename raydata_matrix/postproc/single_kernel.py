#!/usr/bin/env python
# -*- coding: utf-8 -*-

# -------------------------------------------------------------------
#   Filename:  single_kernel.py
#   Purpose:   extracts one kernel from an ascii file generated by raydata_raymatrix
#   Author:    Kasra Hosseini (edit:MT)
#   Email:     hosseini@geophysik.uni-muenchen.de
#   License:   GPLv3
# -------------------------------------------------------------------

# -----------------------------------------------------------------------
# ----------------Import required Modules (Python and Obspy)-------------
# -----------------------------------------------------------------------

# Required Python modules will be imported in this part.

import glob
import numpy as np
import os
import shutil
import pyvtk as pvtk
import sys

# -----------------------------------------------------------------------
# ---------------------------- INPUT ------------------------------------
# -----------------------------------------------------------------------

# where are the band dir from raydata_matrix
path_dir = '/Users/maria/PhD/Codes/__TEST_DATA/OUTPUT/P_32_85_22.05.2017_the17/rdrm_crust2/P_the17_band01_3_dir'

# name of vertex and facet file
vertex_file = 'vertices.h4'
facet_file = 'facets.h4'

kernel_nr = 1

def vtk_single_kernel(direname, vertex_file, facet_file):
    """
    VTK file generator out of all the results of all runs
    ATTENTION: ascii.matrix.* should be moved to one dir (direname)
    INFO:
    - facet file is indexed from 0
    - BUT! ascii.* files are indexed from 1, so we need to subtract them (-1)
    - When describing the cells in terms of point indices, the points must be
    indexed starting at 0.
    """
    #import ipdb;
    #ipdb.set_trace()
    print '\n======>> Creating VTK file'
    ascii_file = glob.glob(os.path.join(direname, 'ascii.matrixT.*'))[0]

    print '------> Load Vertex file'
    mesh_points = np.loadtxt(os.path.join(direname, vertex_file),
                             skiprows=2, comments='#')
    print '------> Load Facet file'
    mesh_facets = np.loadtxt(os.path.join(direname, facet_file),
                             dtype=np.int, skiprows=1, comments='#')

    mat_val_all = [0.0] * len(mesh_points)
    mat_val_dt_all = [0.0] * len(mesh_points)

    print '\n------> create VTK file %s' % ascii_file

    fmatrix = open(os.path.join(ascii_file), 'r')
    fmatrix_r = fmatrix.readlines()
    mat_indx = []
    mat_val = []
    mat_val_dt = []
    counter = 0

    if len(fmatrix_r) < 7:
        sys.exit('The ascii file does not contain enough kernels to '
                 'produce a vtk file. Length of ascii file: %s' % len(fmatrix_r))

    for j in range(5, 7):
        # import ipdb; ipdb.set_trace()
        if np.mod(j, 1000) == 0:
            print '%s/%s' % (j, len(fmatrix_r))
        if counter == 3:
            counter = 0
            continue
        if counter == 0:
            # mat_indx: matrix index
            mat_indx_tmp = np.array(fmatrix_r[j].split()).astype(np.int)
            # IF indexing in ASCII file starts from 0,
            # we do not need -1.
            # Otherwise we need it!
            mat_indx = np.append(mat_indx, mat_indx_tmp - 1)
        if counter == 1:
            # mat_val: matrix value
            mat_val_tmp = np.array(fmatrix_r[j].split()).astype(np.float)

            # I guess this values are the ones of the common correction
            ddif = (float(fmatrix_r[j - 3].split()[3]) -
                    (float(fmatrix_r[j - 3].split()[4]) +
                     float(fmatrix_r[j - 3].split()[6]) +
                     float(fmatrix_r[j - 3].split()[7]) +
                     float(fmatrix_r[j - 3].split()[8]))) / float(fmatrix_r[j - 3].split()[5])

            # normalise the time kernels
            mat_val_dt_tmp = np.array(mat_val_tmp).astype(np.float) / \
                             np.sum(np.array(mat_val_tmp).astype(np.float)) * ddif

            mat_val = np.append(mat_val, np.abs(mat_val_tmp))

            mat_val_dt = np.append(mat_val_dt, mat_val_dt_tmp)

        counter += 1

    for i in range(len(mat_indx)):
        mat_val_all[int(mat_indx[i])] += mat_val[i]
        mat_val_dt_all[int(mat_indx[i])] += mat_val_dt[i]
    for i in range(len(mesh_points)):
        num_repetition = np.count_nonzero(mat_indx == np.array(mesh_points[i]))
        if num_repetition < 1:
            continue
        mat_val_dt_all /= num_repetition

    # SAVE vtk files
    print '------> Saving...'
    vtk = pvtk.VtkData(pvtk.UnstructuredGrid(mesh_points,
                                             tetra=mesh_facets),
                       pvtk.PointData(pvtk.Scalars(mat_val_all,
                                                   name='kernel_value')),
                       'Inversion Grid')

    vtk.tofile(os.path.join(direname, 'single_vtk.vtk'))


    vtk = pvtk.VtkData(pvtk.UnstructuredGrid(mesh_points,
                                             tetra=mesh_facets),
                       pvtk.PointData(pvtk.Scalars(mat_val_dt_all,
                                                   name='dt_projected')),
                       'Inversion Grid')
    vtk.tofile(os.path.join(direname, 'single_vtk_dt.vtk'))

    print '------> DONE!'


# run it

vtk_single_kernel(path_dir, vertex_file, facet_file)

